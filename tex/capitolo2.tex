% !TeX spellcheck = en_GB
\chapter{Here goes some title}
\label{capitolo2}
\thispagestyle{empty}

//MANCA DEL TESTO, PRENDERE DA ALTRO COMPUTER

// SUPPONGO DI ESSERE RIMASTA DOVE DEVO PRESENTARE LE VARIE ENTITA' DELL'ARCHITETTURA

It is necessary to develop an underlying architecture to realize \textit{Sticky Policies}, and some of its elements are common among the different solutions. They include
 \begin{itemize}
 	\item The \textit{Data Owner} has a finite collection of data, which she wants to protect through fine-grained policies.
 	\item A trusted entity which is in charge of securely storing data and generating encryption keys.
 	\item A \textit{Service Provider} should be considered as third party which requests data usage.
 \end{itemize}
The role and implementation of the trusted entity changes accordingly to the chosen encryption scheme and protocol.

We will now examine the main solutions available in literature, and consider their main advantages and disadvantages. It is worth saying beforehand that every solution cannot overlook the trust in the chosen third party: mainly, because once the data is decrypted it can be shared by the third party without any concern; secondly, due to the need of proving the remote hardware machines to be reliable (i.e. it always behaves the way it should, for the intended purpose). This latter issue has been dealt with through the use of Trusted Platform Modules \cite{standard2009trusted}.

\section{Hybrid Cryptosystem}
In this scenario, we use both asymmetric and symmetric cryptography to achieve the required \textit{stickyness} of the policies. The data exchange between the data owner and the service provider is always mediated by a \textit{Trust Authority}, a semi-trusted third party which checks the compliance of the service provider with the specified policies. A formal protocol for message exchange is suggested in \cite{pearson2011sticky}: \texttt{Policy, Enc(PubTA, K||h(Policy)), Sig(PrivUser, Enc(PubTA, K||h(Policy))), Enc(K, PII)}. This ensures that the policy always sticks to its data, and its integrity can be verified through a secure hashing function. Moreover, the combined usage of TA's public key and the data owner's private key ensure both confidentiality and authenticity. In this scenario, the service provider receives data, encrypted with a symmetric one-time-use key \textit{K}, together with the policy and \textit{K}, encrypted with the public key of the Trust Authority and signed by the user. The service provider will interact with the Trust Authority to prove its reliability, eventually receiving the symmetric key \textit{K}.

This implementation relies heavily on the Public Key Infrastructure, and requires procedures for management and verification of X.509 certificates. A slightly different option would involve an additional \textit{Trust Authority} to just analyse the policies and verify their compliance, without taking care of keys generation and management. This entity must be always reachable from the internet and, together with the Certification Authority, may constitute a target for attacks: first, it constitutes a \textit{single point of failure}; additionally, if compromised, it could infect the data owner (for example through phishing attacks) or act as a man in the middle, decrypting \texttt{PII}.

In both cases, this solution proves to be computationally heavy and it does not solve the main issue of trusting the service provider not to illegitimately share data.

\section{Attribute-Based Access Control}
The Attribute-Based Access Control (ABAC) paradigm well fits our environment: by describing users and objects through a set of attributes, it allows fine-grained policy specifications for data protection. However, it requires a precise definition of the attributes which are to be evaluated, together with the implementation of the architecture required to process and enforce policies. The XACML standard \cite{standard2005extensible} provides a valid reference by defining not only the attributes and structure for rules, but also the roles and components of the architecture.

For the sake of simplicity, suppose we need only the \textit{Policy Enforcement Point} from the whole XACML architecture, since we assume that the data owner has a client-side module which is able to generate the required XML policies. The data owner trusts the \textit{Policy Enforcement Point} to be both a secure storage for its personal data and to evaluate correctly the reliability of the service provider.

This solution allows a better data protection in terms of granularity, and it is also more efficient once the architecture has been implemented; nonetheless, it shows the same weaknesses as the Hybrid Cryptosystem. Additionally, the effort required for architecture implementation and rule generation should not be underestimated. It is also remarkable that the mobile environment evolves quickly and is exceptionally fragmented and varied, characteristics which make it more difficult to establish fixed attributes.

In this context, we can also consider Ciphertext-Policy Attribute-Based Encryption \cite{Bethencourt2007Cyphertext}, which eliminates the risks related to PEP vulnerability.
// CONTROLLARE SE è VERO! CHIUDERE QUESTO PARAGRAFO IN BREVE

\section{Identity-Based Encryption}
 
A \textit{Trusted Third Party} which manages key and certificate emissions in case they are needed. It is assumed that the data owner fully trusts this entity. Other characteristics include being able to generate cryptographic keys with a secure algorithm, being always available for certificate verification and key requests, being able to identify users before key emission.

A \textit{Policy Enforcement Point} which is used as secure storage from the data owner. The PEP should be able to understand the specified policies and to share data accordingly; consequently, it should be always available and secure against attacks from the network. Since it does not manage keys issue




 una implementazione simile \`e prevista all’interno dello standard XACML \cite{standard2005extensible}. Il linguaggio XACML definisce uno standard per l’implementazione dell’Attribute-Based Access Control grazie a un'infrastruttura che distribuisce i compiti di creazione, memorizzazione, verifica ed applicazione delle politiche scelte. Fra di esse, l’entit\`a di \textit{enforcement} \`e quella che pi\`u si adatta ed \`e necessaria nel contesto delle \textit{sticky policies}, supponendo che sia il DO a formulare le politiche di divulgazione e utilizzo dei suoi dati. 

Ci\`o richiederebbe per\`o che tale PEP si occupasse anche dei compiti strettamente relativi agli aspetti crittografici o di sicurezza come gestione e pubblicazione delle chiavi in caso di PKE, generazione delle chiavi private ed identificazione in caso di IBE, eccetera. In altre parole, dovrebbe essere completamente fidata, costituire uno storage sicuro, essere sempre online e disponibile, introducendo all’interno dell’architettura un \textit{single point of failure}. Per sgravare il PEP da alcuni di questi compiti, diminuendo quindi il livello di affidabilità richiesto, è possibile prevedere un'ulteriore entit\`a chiamata \textit{Trusted Third Party} \cite{tang2008using}: TTP mantiene il ruolo di gestore delle chiavi e di attuatore delle verifiche dell’identit\`a, mentre il PEP si limita al controllo delle policy per la divulgazione dei dati. Ci\`o aumenta la sicurezza in quanto l’affidabilit\`a richiesta per il PEP \`e minore.

Nello stesso articolo, Tang fornisce un’analisi completa delle attuali tecniche disponibili per l’implementazione di \textit{sticky policies}: PKI, IBE, (CP-) ABE e PRE, suggerendo una quinta possibilit\`a, TPRE, per migliorare l’efficienza di PRE. Vediamone alcune in dettaglio.

L’articolo \cite{pearson2011sticky} ed il progetto EnCoRe mostrano una possibile implementazione di SP tramite l’utilizzo di politiche espresse in formato XML e architettura a chiave pubblica con cifrario ibrido per l’invio delle politiche insieme ai dati offuscati. L’aderenza delle politiche ai dati viene ottenuta mediante la cifratura della chiave simmetrica insieme all’hash delle stesse: il messaggio sar\`a poi decifrato da una terza parte fidata (TA) che si occupa anche di verificare l’affidabilit\`a del \textit{service provider} che richiede le informazioni. Come \`e possibile intuire, questa soluzione richiede l’esistenza di una infrastruttura per il supporto di certificati e l’erogazione di chiavi per cifratura e firma; essa riveste anche il ruolo di garante delle \textit{policies} (deve verificare l’attendibilit\`a del SP prima di rilasciare la chiave simmetrica di sessione K) e mantenere un sistema di logging sicuro a questo scopo. In questo contesto, ogni utente che volesse tutelare la propria privacy deve prima ottenere una coppia di chiavi. 

\`E possibile aggiungere alle entit\`a in gioco uno \textit{storage sicuro} che si occupi di mantenere il dato offuscato al posto del singolo DO.

In generale, questo scenario prevede l’interazione con una singola TA per il rilascio dei dati, mentre il coinvolgimento di un numero maggiore di entit\`a fidate può migliorare il livello di sicurezza garantito, impedendo collusioni o violazioni. Si vedr\`a pi\`u avanti che ci\`o \`e possibile mediante l’utilizzo di uno schema di threshold cryptography \cite{shamir1979share}, menzionato come alternativa insieme alla identity-based cryptography \cite{shamir1984identity}.

La possibilit\`a dell’utilizzo di IBE viene esplorata in \cite{mont2003towards}, che a sua volta si propone di risolvere alcune “open issues” come la "\textit{stickyness}" dei dati e l’utilizzo di un maggior numero di TA.

IBE \cite{shamir1984identity} \`e una tipologia di schema crittografico che permette sia di firmare che di cifrare dati. Le sue potenzialit\`a rispetto all’infrastruttura PKI sono l’eliminazione dell’infrastruttura stessa (chiavi pubbliche e private, certificati, …) a favore di un sistema in cui la chiave pubblica \`e un attributo univoco non ripudiabile (come ad esempio l’indirizzo email) e la chiave privata viene generata su richiesta, in seguito ad identificazione, da un’entit\`a fidata detta PKG (Private Key Generator).
Ad oggi esistono alcune implementazioni di IBE: alcune di utilizzo commerciale (sviluppate da HPE Security \cite{IBEimplVoltage} basate sullo standard \cite{boyen2007identity}), altre per scopi universitari e di ricerca (\cite{Lynn2013}, \cite{ducas2016}).

In questo scenario, si sceglie di usare come chiave di cifratura una stringa che costituisce la \textit{sticky policy} stessa: ci\`o realizza la \textit{stickyness} tramite associazione univoca tra dati cifrati e chiave, permettendo anche di preservare l’integrit\`a dei dati. La TA sar\`a poi in grado di generare la corrispondente chiave di decifrazione.

L’utilizzo di IBE permette il coinvolgimento di pi\`u di una TA al fine di ottenere la divulgazione dei dati personali, in quanto i dati non sono pi\`u legati obbligatoriamente ad una sola TA a causa della chiave. In particolare ci\`o può essere ottenuto mediante l’utilizzo di un \textit{threshold scheme} \cite{shamir1979share}, \cite{sahai2005fuzzy}: la chiave per decifrare il dato, o eventualmente il dato stesso, viene divisa in un numero n di parti, ed almeno \textit{k} TA devono completare il processo di verifica per rilasciare la chiave e permettere la decifrazione del dato. L’utilizzo di questo schema comporterebbe l’innalzamento dei livelli di sicurezza, pur richiedendo un impegno computazionale maggiore per la creazione dello schema.

Il protocollo usato \`e, ad alto livello, lo stesso presentato nel precedente paper: l’EU procede alla scelta di una politica di protezione e all’offuscamento dei dati, che trasmette poi al \textit{service provider} richiedente. Questi inizia una procedura di identificazione presso la TA al fine di ricevere la chiave di decifrazione. Anche in questa soluzione si fa esplicitamente uso di moduli \textit{trusted computing} che permettano di verificare l’affidabilit\`a della piattaforma hardware e del software remoto e di un sistema di logging affidabile. Non viene risolta la problematica della pericolosit\`a dell’utilizzo dei dati dopo la loro decifrazione.

La soluzione proposta \`e per\`o di troppo alto livello, in quanto presenta alcune possibili vulnerabilit\`a: la cifratura per mezzo della policy \`e facilmente replicabile o riutilizzabile (Tang nel suo \cite{tang2008using} suggerisce un esempio di \texttt{ID||timestamp}), e in caso di rottura del cifrario rende la policy inutilizzabile, in quanto si richiede il cambio della chiave. Tuttavia questo approccio \`e quello che permette, insieme a CP-ABE, la maggior aderenza delle policies ai dati.

Inoltre, l’articolo di Mont, Pearson e Siani non prende in esame le tecniche di Proxy Reencryption \cite{green2007identity} e di cyphertext-policy Attribute-Based Encryption \cite{bethencourt2007ciphertext} esaminate invece da Tang. Il secondo caso presenta evidenti vantaggi in quanto parte delle condizioni da soddisfare \`e gi\`a verificata al momento della generazione della chiave di ogni destinatario, che potr\`a decifrare dei messaggi solo se possiede determinati attributi. In questo senso, questa tecnica permette di realizzare un controllo a grana molto pi\`u fine, ma presenta un notevole svantaggio in caso sia necessario sostituire una chiave privata, poich\'e questa non si riferisce ad un singolo utente ma ad una categoria di utenti (e di relativi messaggi).

La PRE \`e invece adatta al caso delle \textit{sticky policies} in quanto permette maggiore interoperabilit\`a fra tecniche crittografiche (PKE e IBE) ed elimina la necessit\`a di uno storage sicuro. Come nel caso di PKE, la \textit{stickyness} \`e realizzata attraverso il PEP, che controlla la validit\`a delle condizioni imposte prima di procedere alla \textit{reencryption} per il destinatario. Questo schema \`e per\`o pi\`u efficiente dello schema PKE nel caso in cui lo stesso testo vada mandato a destinatari diversi, poich\'e il mittente si occupa di una sola cifratura, e sar\`a poi il PEP ad occuparsi, se e quando necessario, di cifrarlo per lo specifico destinatario.

Inoltre, applicazioni simili a quella delle \textit{sticky policies} sono mostrate in \cite{green2007identity} come possibili future applicazioni della proxy reencryption. In particolare si sottolineano due proposte: la prima, discussa anche in altri paper (), riguarda lo storage di files cifrati, che elimina la necessit\`a di uno storage sicuro. La seconda assomiglia a quanto detto precedentemente per Mont \cite{mont2003towards}: si tratta di decifrare dei dati inserendo, oltre all’identit\`a del destinatario, anche altri attributi necessari alla decifrazione, come l’appartenenza ad un intervallo temporale o il possesso di determinate autorizzazioni di accesso.
