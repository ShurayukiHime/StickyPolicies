\chapter{Here goes some title}
\label{capitolo2}
\thispagestyle{empty}

\section{sezione} Spesso, per l’erogazione di un servizio in rete, \`e necessaria da parte di un utente la divulgazione dei propri dati personali. A volte \`e sufficiente il coinvolgimento di una sola entit\`a, il \textit{service provider} (SP), mentre in altri casi i dati possono essere trasmessi a terze parti per l’ottenimento del servizio, o per finalit\`a di mercato. Tali informazioni riservate possono viaggiare anche molto lontano, finendo in Paesi diversi da quello di partenza, processate da aziende con sistemi cos\`i complessi da perdere infine la cognizione di quali dati siano effettivamente stati raccolti e condivisi fra \textit{service providers}.
In questo scenario si aprono diversi spunti riguardo all’utilizzo dei dati personali: la trasmissione (anche solo parziale) era autorizzata? Le politiche per il rispetto della privacy alle quali il \textit{data owner} ha aderito sono rispettate anche all’interno delle terze parti? Quali fattori aggiuntivi entrano in gioco (leggi nazionali ed internazionali, politiche aziendali…)?

Le \textit{sticky policies} si propongono come strumento in grado di rispondere a queste necessità: si tratta di metadati che specificano l’utilizzo consentito dei dati a cui fanno riferimento, ed ai quali “restano attaccate” (da cui il nome). Sono espresse in un formato \textit{machine readable}, che ne permette l’automatica lettura e applicazione nella granularit\`a desiderata. 

L’architettura necessaria per realizzare questa soluzione tecnologica si compone, nella sua versione più scarna, di tre componenti: il proprietario dei dati (DO), una terza parte interessata ai dati (spesso un SP) ed un’autorit\`a con un grado di affidabilit\`a variabile. Questa struttura non è nuova, ma gi\`a realizzata e in uso per quanto riguarda l’infrastruttura a chiave pubblica; inoltre, una implementazione simile \`e prevista all’interno dello standard XACML \cite{standard2005extensible}. Il linguaggio XACML definisce uno standard per l’implementazione dell’Attribute-Based Access Control grazie a un'infrastruttura che distribuisce i compiti di creazione, memorizzazione, verifica ed applicazione delle politiche scelte. Fra di esse, l’entit\`a di \textit{enforcement} \`e quella che pi\`u si adatta ed \`e necessaria nel contesto delle \textit{sticky policies}, supponendo che sia il DO a formulare le politiche di divulgazione e utilizzo dei suoi dati. 

Ci\`o richiederebbe per\`o che tale PEP si occupasse anche dei compiti strettamente relativi agli aspetti crittografici o di sicurezza come gestione e pubblicazione delle chiavi in caso di PKE, generazione delle chiavi private ed identificazione in caso di IBE, eccetera. In altre parole, dovrebbe essere completamente fidata, costituire uno storage sicuro, essere sempre online e disponibile, introducendo all’interno dell’architettura un \textit{single point of failure}. Per sgravare il PEP da alcuni di questi compiti, diminuendo quindi il livello di affidabilità richiesto, è possibile prevedere un'ulteriore entit\`a chiamata \textit{Trusted Third Party} \cite{tang2008using}: TTP mantiene il ruolo di gestore delle chiavi e di attuatore delle verifiche dell’identit\`a, mentre il PEP si limita al controllo delle policy per la divulgazione dei dati. Ci\`o aumenta la sicurezza in quanto l’affidabilit\`a richiesta per il PEP \`e minore.

Nello stesso articolo, Tang fornisce un’analisi completa delle attuali tecniche disponibili per l’implementazione di \textit{sticky policies}: PKI, IBE, (CP-) ABE e PRE, suggerendo una quinta possibilit\`a, TPRE, per migliorare l’efficienza di PRE. Vediamone alcune in dettaglio.

L’articolo \cite{pearson2011sticky} ed il progetto EnCoRe mostrano una possibile implementazione di SP tramite l’utilizzo di politiche espresse in formato XML e architettura a chiave pubblica con cifrario ibrido per l’invio delle politiche insieme ai dati offuscati. L’aderenza delle politiche ai dati viene ottenuta mediante la cifratura della chiave simmetrica insieme all’hash delle stesse: il messaggio sar\`a poi decifrato da una terza parte fidata (TA) che si occupa anche di verificare l’affidabilit\`a del \textit{service provider} che richiede le informazioni. Come \`e possibile intuire, questa soluzione richiede l’esistenza di una infrastruttura per il supporto di certificati e l’erogazione di chiavi per cifratura e firma; essa riveste anche il ruolo di garante delle \textit{policies} (deve verificare l’attendibilit\`a del SP prima di rilasciare la chiave simmetrica di sessione K) e mantenere un sistema di logging sicuro a questo scopo. In questo contesto, ogni utente che volesse tutelare la propria privacy deve prima ottenere una coppia di chiavi. 

\`E possibile aggiungere alle entit\`a in gioco uno \textit{storage sicuro} che si occupi di mantenere il dato offuscato al posto del singolo DO.

Il protocollo di scambio dei dati proposto in questo articolo lega la \textit{policy} ai dati per mezzo della cifratura con chiave pubblica della chiave simmetrica; la stessa operazione garantisce l’integrit\`a della \textit{policy} per mezzo della funzione di hashing. Infine, questo dato cifrato viene firmato dall’utente proprietario, per garantirne la paternit\`a. Dal protocollo si osserva che non \`e possibile modificare il formato dei messaggi cambiando la chiave di sessione o le \textit{policies}, mentre sarebbe possibile effettuare attacchi di replay, anche se di poca utilit\`a, per l’assenza di \textit{timestamps} nel protocollo. Sarebbe possibile spacciarsi per la TA presso il SP, intercettando il messaggio legittimo e inserendo nel messaggio di risposta una chiave contraffatta (per impedire la cifratura dei dati, o produrre collisioni in caso siano note, o ancora inserire nel messaggio iniziale dati contraffatti (not really sure about this), decifrabili con la chiave fasulla.

In generale, questo scenario prevede l’interazione con una singola TA per il rilascio dei dati, mentre il coinvolgimento di un numero maggiore di entit\`a fidate può migliorare il livello di sicurezza garantito, impedendo collusioni o violazioni. Si vedr\`a pi\`u avanti che ci\`o \`e possibile mediante l’utilizzo di uno schema di threshold cryptography \cite{shamir1979share}, menzionato come alternativa insieme alla identity-based cryptography \cite{shamir1984identity}.

Rimane inoltre come punto aperto l’affidabilit\`a dei SP: una volta infatti che la TA ha rilasciato la chiave di decifrazione dei dati sensibili, non vi è pi\`u alcun modo di controllare l’utilizzo che ne viene fatto, e l’applicazione delle politiche di protezione della privacy \`e lasciata alle “buone intenzioni” dello specifico SP. Altri punti aperti riguardano il costo computazionale relativo alla gestione dell’infrastruttura PKI con le aggiunte necessarie e l’emissione di certificati per ogni utente che volesse avvalersi di \textit{sticky policies}. Infine, si deve anche considerare la necessit\`a di provare l’affidabilit\`a di una macchina remota (si intende che la macchina si comporta sempre come desiderato, per lo scopo voluto). A tale scopo sono stati sviluppati alcuni moduli hardware che hanno una funzione di “root of trust” e che permettono di garantire l’affidabilit\`a e l’integrit\`a della macchina e del software in funzione. Un dispositivo di questo tipo \`e basato su Trusted Platform Module \cite{standard2009trusted}.
La possibilit\`a dell’utilizzo di IBE viene esplorata in \cite{mont2003towards}, che a sua volta si propone di risolvere alcune “open issues” come la "\textit{stickyness}" dei dati e l’utilizzo di un maggior numero di TA.

IBE \cite{shamir1984identity} \`e una tipologia di schema crittografico che permette sia di firmare che di cifrare dati. Le sue potenzialit\`a rispetto all’infrastruttura PKI sono l’eliminazione dell’infrastruttura stessa (chiavi pubbliche e private, certificati, …) a favore di un sistema in cui la chiave pubblica \`e un attributo univoco non ripudiabile (come ad esempio l’indirizzo email) e la chiave privata viene generata su richiesta, in seguito ad identificazione, da un’entit\`a fidata detta PKG (Private Key Generator).
Ad oggi esistono alcune implementazioni di IBE: alcune di utilizzo commerciale (sviluppate da HPE Security \cite{IBEimplVoltage} basate sullo standard \cite{boyen2007identity}), altre per scopi universitari e di ricerca (\cite{Lynn2013}, \cite{ducas2016}).

In questo scenario, si sceglie di usare come chiave di cifratura una stringa che costituisce la \textit{sticky policy} stessa: ci\`o realizza la \textit{stickyness} tramite associazione univoca tra dati cifrati e chiave, permettendo anche di preservare l’integrit\`a dei dati. La TA sar\`a poi in grado di generare la corrispondente chiave di decifrazione.

L’utilizzo di IBE permette il coinvolgimento di pi\`u di una TA al fine di ottenere la divulgazione dei dati personali, in quanto i dati non sono pi\`u legati obbligatoriamente ad una sola TA a causa della chiave. In particolare ci\`o può essere ottenuto mediante l’utilizzo di un \textit{threshold scheme} \cite{shamir1979scheme}, \cite{sahai2005fuzzy}: la chiave per decifrare il dato, o eventualmente il dato stesso, viene divisa in un numero n di parti, ed almeno \textit{k} TA devono completare il processo di verifica per rilasciare la chiave e permettere la decifrazione del dato. L’utilizzo di questo schema comporterebbe l’innalzamento dei livelli di sicurezza, pur richiedendo un impegno computazionale maggiore per la creazione dello schema.

Il protocollo usato \`e, ad alto livello, lo stesso presentato nel precedente paper: l’EU procede alla scelta di una politica di protezione e all’offuscamento dei dati, che trasmette poi al \textit{service provider} richiedente. Questi inizia una procedura di identificazione presso la TA al fine di ricevere la chiave di decifrazione. Anche in questa soluzione si fa esplicitamente uso di moduli \textit{trusted computing} che permettano di verificare l’affidabilit\`a della piattaforma hardware e del software remoto e di un sistema di logging affidabile. Non viene risolta la problematica della pericolosit\`a dell’utilizzo dei dati dopo la loro decifrazione.

La soluzione proposta \`e per\`o di troppo alto livello, in quanto presenta alcune possibili vulnerabilit\`a: la cifratura per mezzo della policy \`e facilmente replicabile o riutilizzabile (Tang nel suo \cite{tang2008using} suggerisce un esempio di \texttt{ID||timestamp}), e in caso di rottura del cifrario rende la policy inutilizzabile, in quanto si richiede il cambio della chiave. Tuttavia questo approccio \`e quello che permette, insieme a CP-ABE, la maggior aderenza delle policies ai dati.

Inoltre, l’articolo di Mont, Pearson e Siani non prende in esame le tecniche di Proxy Reencryption \cite{green2007identity} e di cyphertext-policy Attribute-Based Encryption \cite{bethencourt2007ciphertext} esaminate invece da Tang. Il secondo caso presenta evidenti vantaggi in quanto parte delle condizioni da soddisfare \`e gi\`a verificata al momento della generazione della chiave di ogni destinatario, che potr\`a decifrare dei messaggi solo se possiede determinati attributi. In questo senso, questa tecnica permette di realizzare un controllo a grana molto pi\`u fine, ma presenta un notevole svantaggio in caso sia necessario sostituire una chiave privata, poich\'e questa non si riferisce ad un singolo utente ma ad una categoria di utenti (e di relativi messaggi).

La PRE \`e invece adatta al caso delle \textit{sticky policies} in quanto permette maggiore interoperabilit\`a fra tecniche crittografiche (PKE e IBE) ed elimina la necessit\`a di uno storage sicuro. Come nel caso di PKE, la \textit{stickyness} \`e realizzata attraverso il PEP, che controlla la validit\`a delle condizioni imposte prima di procedere alla \textit{reencryption} per il destinatario. Questo schema \`e per\`o pi\`u efficiente dello schema PKE nel caso in cui lo stesso testo vada mandato a destinatari diversi, poich\'e il mittente si occupa di una sola cifratura, e sar\`a poi il PEP ad occuparsi, se e quando necessario, di cifrarlo per lo specifico destinatario.

Inoltre, applicazioni simili a quella delle \textit{sticky policies} sono mostrate in \cite{green2007identity} come possibili future applicazioni della proxy reencryption. In particolare si sottolineano due proposte: la prima, discussa anche in altri paper (), riguarda lo storage di files cifrati, che elimina la necessit\`a di uno storage sicuro. La seconda assomiglia a quanto detto precedentemente per Mont \cite{mont2003towards}: si tratta di decifrare dei dati inserendo, oltre all’identit\`a del destinatario, anche altri attributi necessari alla decifrazione, come l’appartenenza ad un intervallo temporale o il possesso di determinate autorizzazioni di accesso.
